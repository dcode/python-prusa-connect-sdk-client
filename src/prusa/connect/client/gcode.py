"""G-code metadata parsing utilities.

This module provides tools to extract metadata from G-code and Binary G-code (.bgcode)
files, specifically focusing on headers generated by PrusaSlicer and Slic3r.

How to use the most important parts:
- `parse_gcode_metadata(path)`: Give it a filepath to a standard or binary G-code file, and it returns a
  `GCodeMetadata` object detailing estimated print time, filament type, and the slicer used.
"""

import dataclasses
import pathlib
import re


@dataclasses.dataclass
class GCodeMetadata:
    """Metadata extracted from a G-code file."""

    estimated_time: int | None = None  # in seconds
    estimated_time_mode: str | None = None  # "normal" or "stealth"
    gcode_type: str | None = None  # "ascii" or "binary"
    producer: str | None = None
    filament_type: str | None = None
    filament_used: float | None = None  # in mm
    nozzle_diameter: float | None = None
    printer_model: str | None = None
    layer_height: float | None = None
    fill_density: str | None = None
    bed_temperature: int | None = None
    temperature: int | None = None


def parse_gcode_header(file_path: pathlib.Path, max_read: int = 100 * 1024) -> GCodeMetadata:
    """Parses a G-code or Binary G-code (.bgcode) file to extract metadata.

    This parser is "hardware-aware" and handles both standard ASCII G-code
    and Prusa's binary format by scanning for key metadata patterns.

    Args:
        file_path: Path to the .gcode or .bgcode file.
        max_read: Maximum bytes to read from the start of the file.

    Returns:
        A GCodeMetadata object.
    """
    metadata = GCodeMetadata()

    try:
        # Read as binary to handle both formats and avoids encoding crashes
        with open(file_path, "rb") as f:
            magic = f.read(4)
            metadata.gcode_type = "binary" if magic in (b"GCDE", b"PGC\x01") else "ascii"
            f.seek(0)
            raw_content = f.read(max_read)

        # Decode using latin-1 to preserve all byte values for regex matching
        content = raw_content.decode("latin-1")

        # Regex patterns for PrusaSlicer/Slic3r metadata
        # We handle both ASCII (comments with ';') and Binary (raw key=value)
        # Using [; \x00\n] as potential delimiters before the key
        patterns = {
            "estimated_time": (
                r"(?:[; \x00\n]|^)estimated printing time \((normal|stealth) mode\)\s*=\s*"
                r"(?:(\d+)h )?(?:(\d+)m )?(\d+)s"
            ),
            "estimated_time_bg": r"(estimated_printing_time_normal|estimated_printing_time_stealth)\s*=\s*(\d+)",
            "filament_type": r"(?:[; \x00\n]|^)filament_type\s*=\s*([^\n\r\t\x00;]+)",
            "filament_used": r"(?:[; \x00\n]|^)filament used \[mm\]\s*=\s*([\d.]+)",
            "nozzle_diameter": r"(?:[; \x00\n]|^)nozzle_diameter\s*=\s*([\d.]+)",
            "printer_model": r"(?:[; \x00\n]|^)printer_model\s*=\s*([^\n\r\t\x00;]+)",
            "producer": r"(?:[; \x00\n]|^)(?:generated by |Producer=)([^\n\r\t\x00;]+)",
            "layer_height": r"(?:[; \x00\n]|^)layer_height\s*=\s*([\d.]+)",
            "fill_density": r"(?:[; \x00\n]|^)fill_density\s*=\s*([^\n\r\t\x00;]+)",
            "bed_temperature": r"(?:[; \x00\n]|^)bed_temperature\s*=\s*(\d+)",
            "temperature": r"(?:[; \x00\n]|^)temperature\s*=\s*(\d+)",
        }

        # 1. Handle estimated time (ASCII and possible binary matches)
        if match := re.search(patterns["estimated_time"], content):
            mode, h, m, s = match.groups()
            metadata.estimated_time_mode = mode
            seconds = int(s)
            if m:
                seconds += int(m) * 60
            if h:
                seconds += int(h) * 3600
            metadata.estimated_time = seconds
        elif match := re.search(patterns["estimated_time_bg"], content):
            mode_key, val = match.groups()
            metadata.estimated_time = int(val)
            metadata.estimated_time_mode = "normal" if "normal" in mode_key else "stealth"

        # 2. Handle printer model and filament type
        if match := re.search(patterns["printer_model"], content):
            metadata.printer_model = match.group(1).strip()

        if match := re.search(patterns["filament_type"], content):
            metadata.filament_type = match.group(1).strip()

        # 3. Handle others
        if match := re.search(patterns["filament_used"], content):
            metadata.filament_used = float(match.group(1))

        if match := re.search(patterns["nozzle_diameter"], content):
            metadata.nozzle_diameter = float(match.group(1))

        if match := re.search(patterns["layer_height"], content):
            metadata.layer_height = float(match.group(1))

        if match := re.search(patterns["fill_density"], content):
            metadata.fill_density = match.group(1).strip()

        if match := re.search(patterns["bed_temperature"], content):
            metadata.bed_temperature = int(match.group(1))

        if match := re.search(patterns["temperature"], content):
            metadata.temperature = int(match.group(1))

        if match := re.search(patterns["producer"], content):
            metadata.producer = match.group(1).strip()

    except Exception:
        # Hardware safety: return partially filled metadata rather than crashing
        pass

    return metadata
